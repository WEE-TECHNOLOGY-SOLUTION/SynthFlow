#include "../../include/js_transpiler.h"
#include <iostream>

void JSTranspiler::indent() {
    for (int i = 0; i < indentLevel; ++i) {
        output << "    ";
    }
}

void JSTranspiler::emit(const std::string& code) {
    output << code;
}

void JSTranspiler::emitLine(const std::string& code) {
    indent();
    output << code << "\n";
}

std::string JSTranspiler::transpile(const std::vector<std::unique_ptr<Statement>>& statements) {
    // Add runtime header
    output << "// Generated by SynthFlow JavaScript Transpiler\n";
    output << "// SynthFlow v0.0.2\n\n";
    
    // Add runtime helpers
    output << "// SynthFlow Runtime\n";
    output << "const print = (...args) => console.log(...args);\n";
    output << "const input = (prompt) => { throw new Error('input() not supported in browser'); };\n";
    output << "const len = (x) => x.length;\n";
    output << "const str = (x) => String(x);\n";
    output << "const read_file = (path) => { throw new Error('read_file() not supported in browser'); };\n";
    output << "const write_file = (path, content) => { throw new Error('write_file() not supported in browser'); };\n";
    output << "\n// User Code\n";
    
    for (const auto& stmt : statements) {
        stmt->accept(*this);
    }
    
    return output.str();
}

void JSTranspiler::visit(IntegerLiteral* node) {
    emit(std::to_string(node->value));
}

void JSTranspiler::visit(FloatLiteral* node) {
    emit(std::to_string(node->value));
}

void JSTranspiler::visit(StringLiteral* node) {
    emit("\"" + node->value + "\"");
}

void JSTranspiler::visit(BooleanLiteral* node) {
    emit(node->value ? "true" : "false");
}

void JSTranspiler::visit(Identifier* node) {
    emit(node->name);
}

void JSTranspiler::visit(BinaryExpression* node) {
    emit("(");
    node->left->accept(*this);
    
    std::string op = node->op;
    if (op == "and") op = "&&";
    else if (op == "or") op = "||";
    
    emit(" " + op + " ");
    node->right->accept(*this);
    emit(")");
}

void JSTranspiler::visit(UnaryExpression* node) {
    std::string op = node->op;
    if (op == "not") op = "!";
    
    emit(op);
    node->operand->accept(*this);
}

void JSTranspiler::visit(AssignmentExpression* node) {
    node->left->accept(*this);
    emit(" = ");
    node->right->accept(*this);
}

void JSTranspiler::visit(CallExpression* node) {
    emit(node->callee + "(");
    for (size_t i = 0; i < node->arguments.size(); ++i) {
        if (i > 0) emit(", ");
        node->arguments[i]->accept(*this);
    }
    emit(")");
}

void JSTranspiler::visit(ArrayLiteral* node) {
    emit("[");
    for (size_t i = 0; i < node->elements.size(); ++i) {
        if (i > 0) emit(", ");
        node->elements[i]->accept(*this);
    }
    emit("]");
}

void JSTranspiler::visit(ArrayIndexExpression* node) {
    node->array->accept(*this);
    emit("[");
    node->index->accept(*this);
    emit("]");
}

void JSTranspiler::visit(ArrayAssignmentExpression* node) {
    node->array->accept(*this);
    emit("[");
    node->index->accept(*this);
    emit("] = ");
    node->value->accept(*this);
}

void JSTranspiler::visit(VariableDeclaration* node) {
    indent();
    emit("let " + node->name);
    if (node->initializer) {
        emit(" = ");
        node->initializer->accept(*this);
    }
    emit(";\n");
}

void JSTranspiler::visit(ExpressionStatement* node) {
    indent();
    node->expression->accept(*this);
    emit(";\n");
}

void JSTranspiler::visit(BlockStatement* node) {
    emit("{\n");
    indentLevel++;
    for (const auto& stmt : node->statements) {
        stmt->accept(*this);
    }
    indentLevel--;
    indent();
    emit("}");
}

void JSTranspiler::visit(IfStatement* node) {
    indent();
    emit("if (");
    node->condition->accept(*this);
    emit(") ");
    node->thenBranch->accept(*this);
    
    if (node->elseBranch) {
        emit(" else ");
        node->elseBranch->accept(*this);
    }
    emit("\n");
}

void JSTranspiler::visit(WhileStatement* node) {
    indent();
    emit("while (");
    node->condition->accept(*this);
    emit(") ");
    node->body->accept(*this);
    emit("\n");
}

void JSTranspiler::visit(ForStatement* node) {
    indent();
    emit("for (");
    
    if (node->initializer) {
        // Handle variable declaration differently
        if (auto* varDecl = dynamic_cast<VariableDeclaration*>(node->initializer.get())) {
            emit("let " + varDecl->name + " = ");
            if (varDecl->initializer) {
                varDecl->initializer->accept(*this);
            }
        } else {
            node->initializer->accept(*this);
        }
    }
    emit("; ");
    
    if (node->condition) {
        node->condition->accept(*this);
    }
    emit("; ");
    
    if (node->increment) {
        node->increment->accept(*this);
    }
    emit(") ");
    
    node->body->accept(*this);
    emit("\n");
}

void JSTranspiler::visit(BreakStatement*) {
    emitLine("break;");
}

void JSTranspiler::visit(ContinueStatement*) {
    emitLine("continue;");
}

void JSTranspiler::visit(FunctionDeclaration* node) {
    indent();
    emit("function " + node->name + "(");
    for (size_t i = 0; i < node->parameters.size(); ++i) {
        if (i > 0) emit(", ");
        emit(node->parameters[i]);
    }
    emit(") ");
    node->body->accept(*this);
    emit("\n");
}

void JSTranspiler::visit(ReturnStatement* node) {
    indent();
    emit("return");
    if (node->value) {
        emit(" ");
        node->value->accept(*this);
    }
    emit(";\n");
}

void JSTranspiler::visit(NullLiteral* node) {
    (void)node;
    emit("null");
}

void JSTranspiler::visit(TryStatement* node) {
    indent();
    emit("try ");
    if (node->tryBlock) {
        node->tryBlock->accept(*this);
    }
    emit(" catch (" + node->errorVariable + ") ");
    if (node->catchBlock) {
        node->catchBlock->accept(*this);
    }
    emit("\n");
}

void JSTranspiler::visit(LambdaExpression* node) {
    emit("(");
    for (size_t i = 0; i < node->parameters.size(); ++i) {
        if (i > 0) emit(", ");
        emit(node->parameters[i]);
    }
    emit(") => ");
    if (node->body) {
        node->body->accept(*this);
    } else if (node->blockBody) {
        node->blockBody->accept(*this);
    }
}

void JSTranspiler::visit(MatchExpression* node) {
    // Convert match to switch-like IIFE
    emit("(function() { switch (");
    node->subject->accept(*this);
    emit(") {");
    for (auto& matchCase : node->cases) {
        if (!matchCase.pattern) {
            emit(" default: return ");
        } else {
            emit(" case ");
            matchCase.pattern->accept(*this);
            emit(": return ");
        }
        matchCase.result->accept(*this);
        emit(";");
    }
    emit(" } })()");
}

void JSTranspiler::visit(CompoundAssignment* node) {
    node->target->accept(*this);
    emit(" " + node->op + " ");
    node->value->accept(*this);
}

void JSTranspiler::visit(UpdateExpression* node) {
    if (node->prefix) emit(node->op);
    node->operand->accept(*this);
    if (!node->prefix) emit(node->op);
}

void JSTranspiler::visit(InterpolatedString* node) {
    emit("`");
    for (auto& part : node->parts) {
        if (part.isExpression) {
            emit("${");
            part.expr->accept(*this);
            emit("}");
        } else {
            emit(part.text);
        }
    }
    emit("`");
}
