#include "../../include/code_generator.h"
#include <sstream>
#include <iostream>

std::string CodeGenerator::generate(const std::vector<std::unique_ptr<Statement>>& statements) {
    output.clear();
    
    output += "; SynthFlow Intermediate Representation\n";
    output += "; Generated by SynthFlow Compiler\n";
    output += ";\n";
    
    for (const auto& stmt : statements) {
        stmt->accept(this);
    }
    
    return output;
}

void CodeGenerator::visit(IntegerLiteral* node) {
    output += std::to_string(node->value);
}

void CodeGenerator::visit(FloatLiteral* node) {
    output += std::to_string(node->value);
}

void CodeGenerator::visit(StringLiteral* node) {
    output += "\"" + node->value + "\"";
}

void CodeGenerator::visit(BooleanLiteral* node) {
    output += node->value ? "true" : "false";
}

void CodeGenerator::visit(Identifier* node) {
    output += node->name;
}

void CodeGenerator::visit(ArrayLiteral* node) {
    output += "[";
    
    for (size_t i = 0; i < node->elements.size(); ++i) {
        if (i > 0) output += ", ";
        node->elements[i]->accept(this);
    }
    
    output += "]";
}

void CodeGenerator::visit(IndexExpression* node) {
    node->array->accept(this);
    output += "[";
    node->index->accept(this);
    output += "]";
}

void CodeGenerator::visit(AssignmentExpression* node) {
    node->left->accept(this);
    output += " = ";
    node->right->accept(this);
}

void CodeGenerator::visit(BinaryOp* node) {
    output += "(";
    node->left->accept(this);
    
    switch (node->op) {
        case BinaryOp::ADD: output += " + "; break;
        case BinaryOp::SUB: output += " - "; break;
        case BinaryOp::MUL: output += " * "; break;
        case BinaryOp::DIV: output += " / "; break;
        case BinaryOp::MOD: output += " % "; break;
        case BinaryOp::EQ: output += " == "; break;
        case BinaryOp::NE: output += " != "; break;
        case BinaryOp::LT: output += " < "; break;
        case BinaryOp::GT: output += " > "; break;
        case BinaryOp::LE: output += " <= "; break;
        case BinaryOp::GE: output += " >= "; break;
        case BinaryOp::AND: output += " && "; break;
        case BinaryOp::OR: output += " || "; break;
    }
    
    node->right->accept(this);
    output += ")";
}

void CodeGenerator::visit(ExpressionStatement* node) {
    output += "  ";
    node->expression->accept(this);
    output += ";\n";
}

void CodeGenerator::visit(VariableDeclaration* node) {
    output += "  let " + node->name + " = ";
    if (node->initializer) {
        node->initializer->accept(this);
    }
    output += ";\n";
}

void CodeGenerator::visit(FunctionDeclaration* node) {
    output += "fn " + node->name + "(";
    
    for (size_t i = 0; i < node->parameters.size(); ++i) {
        if (i > 0) output += ", ";
        output += node->parameters[i];
    }
    
    output += ") {\n";
    if (node->body) {
        node->body->accept(this);
    }
    output += "}\n";
}

void CodeGenerator::visit(BlockStatement* node) {
    for (const auto& stmt : node->statements) {
        stmt->accept(this);
    }
}

void CodeGenerator::visit(IfStatement* node) {
    output += "  if (";
    node->condition->accept(this);
    output += ") {\n";
    node->thenBranch->accept(this);
    output += "  }";
    
    if (node->elseBranch) {
        output += " else {\n";
        node->elseBranch->accept(this);
        output += "  }";
    }
    output += "\n";
}

void CodeGenerator::visit(WhileStatement* node) {
    output += "  while (";
    node->condition->accept(this);
    output += ") {\n";
    node->body->accept(this);
    output += "  }\n";
}

void CodeGenerator::visit(BreakStatement* node) {
    output += "  break;\n";
}

void CodeGenerator::visit(ContinueStatement* node) {
    output += "  continue;\n";
}

void CodeGenerator::visit(ReturnStatement* node) {
    output += "  return";
    if (node->returnValue) {
        node->returnValue->accept(this);
    }
    output += ";\n";
}