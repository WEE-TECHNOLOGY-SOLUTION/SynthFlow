// SynthFlow Deployment Library
// Deployment automation and configuration management

// ===== Deployment Configuration =====

fn createDeploymentConfig(name: string, environment: string) -> map {
    return {
        "name": name,
        "environment": environment,  // "development", "staging", "production"
        "model_path": "",
        "server": {
            "host": "0.0.0.0",
            "port": 8080,
            "workers": 1
        },
        "resources": {
            "cpu": "1",
            "memory": "1Gi"
        },
        "scaling": {
            "min_replicas": 1,
            "max_replicas": 1,
            "target_cpu_utilization": 80
        },
        "health_check": {
            "path": "/health",
            "interval_seconds": 30,
            "timeout_seconds": 10
        },
        "env_vars": {},
        "secrets": [],
        "labels": {},
        "annotations": {}
    }
}

fn setModelPath(config: map, path: string) -> map {
    config.model_path = path
    return config
}

fn setResources(config: map, cpu: string, memory: string) -> map {
    config.resources.cpu = cpu
    config.resources.memory = memory
    return config
}

fn setScaling(config: map, minReplicas: int, maxReplicas: int, targetCPU: int) -> map {
    config.scaling.min_replicas = minReplicas
    config.scaling.max_replicas = maxReplicas
    config.scaling.target_cpu_utilization = targetCPU
    return config
}

fn addEnvVar(config: map, key: string, value: string) -> map {
    config.env_vars[key] = value
    return config
}

fn addSecret(config: map, name: string) -> map {
    config.secrets = append(config.secrets, name)
    return config
}

fn addLabel(config: map, key: string, value: string) -> map {
    config.labels[key] = value
    return config
}

// ===== Docker Configuration =====

fn generateDockerfile(config: map) -> string {
    let dockerfile = "# Auto-generated by SynthFlow\n"
    dockerfile = dockerfile + "FROM synthflow/runtime:latest\n\n"
    
    dockerfile = dockerfile + "WORKDIR /app\n\n"
    
    dockerfile = dockerfile + "# Copy model\n"
    dockerfile = dockerfile + "COPY " + config.model_path + " /app/model/\n\n"
    
    dockerfile = dockerfile + "# Set environment variables\n"
    let envKeys = keys(config.env_vars)
    for (let i = 0; i < len(envKeys); i = i + 1) {
        let key = envKeys[i]
        dockerfile = dockerfile + "ENV " + key + "=" + config.env_vars[key] + "\n"
    }
    dockerfile = dockerfile + "\n"
    
    dockerfile = dockerfile + "# Expose port\n"
    dockerfile = dockerfile + "EXPOSE " + str(config.server.port) + "\n\n"
    
    dockerfile = dockerfile + "# Health check\n"
    dockerfile = dockerfile + "HEALTHCHECK --interval=" + str(config.health_check.interval_seconds) + "s "
    dockerfile = dockerfile + "--timeout=" + str(config.health_check.timeout_seconds) + "s "
    dockerfile = dockerfile + "CMD curl -f http://localhost:" + str(config.server.port) + config.health_check.path + " || exit 1\n\n"
    
    dockerfile = dockerfile + "# Start server\n"
    dockerfile = dockerfile + "CMD [\"synthflow\", \"serve\", \"--host\", \"" + config.server.host + "\", \"--port\", \"" + str(config.server.port) + "\"]\n"
    
    return dockerfile
}

fn generateDockerCompose(configs: array) -> string {
    let compose = "# Auto-generated by SynthFlow\n"
    compose = compose + "version: '3.8'\n\n"
    compose = compose + "services:\n"
    
    for (let i = 0; i < len(configs); i = i + 1) {
        let config = configs[i]
        compose = compose + "  " + config.name + ":\n"
        compose = compose + "    build: .\n"
        compose = compose + "    ports:\n"
        compose = compose + "      - \"" + str(config.server.port) + ":" + str(config.server.port) + "\"\n"
        
        if (len(keys(config.env_vars)) > 0) {
            compose = compose + "    environment:\n"
            let envKeys = keys(config.env_vars)
            for (let j = 0; j < len(envKeys); j = j + 1) {
                let key = envKeys[j]
                compose = compose + "      - " + key + "=" + config.env_vars[key] + "\n"
            }
        }
        
        compose = compose + "    deploy:\n"
        compose = compose + "      resources:\n"
        compose = compose + "        limits:\n"
        compose = compose + "          cpus: '" + config.resources.cpu + "'\n"
        compose = compose + "          memory: " + config.resources.memory + "\n"
        compose = compose + "\n"
    }
    
    return compose
}

// ===== Kubernetes Configuration =====

fn generateKubernetesDeployment(config: map) -> string {
    let yaml = "# Auto-generated by SynthFlow\n"
    yaml = yaml + "apiVersion: apps/v1\n"
    yaml = yaml + "kind: Deployment\n"
    yaml = yaml + "metadata:\n"
    yaml = yaml + "  name: " + config.name + "\n"
    yaml = yaml + "  labels:\n"
    
    let labelKeys = keys(config.labels)
    for (let i = 0; i < len(labelKeys); i = i + 1) {
        let key = labelKeys[i]
        yaml = yaml + "    " + key + ": " + config.labels[key] + "\n"
    }
    yaml = yaml + "    app: " + config.name + "\n"
    
    yaml = yaml + "spec:\n"
    yaml = yaml + "  replicas: " + str(config.scaling.min_replicas) + "\n"
    yaml = yaml + "  selector:\n"
    yaml = yaml + "    matchLabels:\n"
    yaml = yaml + "      app: " + config.name + "\n"
    yaml = yaml + "  template:\n"
    yaml = yaml + "    metadata:\n"
    yaml = yaml + "      labels:\n"
    yaml = yaml + "        app: " + config.name + "\n"
    yaml = yaml + "    spec:\n"
    yaml = yaml + "      containers:\n"
    yaml = yaml + "      - name: " + config.name + "\n"
    yaml = yaml + "        image: " + config.name + ":latest\n"
    yaml = yaml + "        ports:\n"
    yaml = yaml + "        - containerPort: " + str(config.server.port) + "\n"
    yaml = yaml + "        resources:\n"
    yaml = yaml + "          limits:\n"
    yaml = yaml + "            cpu: \"" + config.resources.cpu + "\"\n"
    yaml = yaml + "            memory: \"" + config.resources.memory + "\"\n"
    yaml = yaml + "          requests:\n"
    yaml = yaml + "            cpu: \"" + config.resources.cpu + "\"\n"
    yaml = yaml + "            memory: \"" + config.resources.memory + "\"\n"
    
    // Environment variables
    if (len(keys(config.env_vars)) > 0) {
        yaml = yaml + "        env:\n"
        let envKeys = keys(config.env_vars)
        for (let i = 0; i < len(envKeys); i = i + 1) {
            let key = envKeys[i]
            yaml = yaml + "        - name: " + key + "\n"
            yaml = yaml + "          value: \"" + config.env_vars[key] + "\"\n"
        }
    }
    
    // Secrets
    if (len(config.secrets) > 0) {
        yaml = yaml + "        envFrom:\n"
        for (let i = 0; i < len(config.secrets); i = i + 1) {
            yaml = yaml + "        - secretRef:\n"
            yaml = yaml + "            name: " + config.secrets[i] + "\n"
        }
    }
    
    // Health checks
    yaml = yaml + "        livenessProbe:\n"
    yaml = yaml + "          httpGet:\n"
    yaml = yaml + "            path: " + config.health_check.path + "\n"
    yaml = yaml + "            port: " + str(config.server.port) + "\n"
    yaml = yaml + "          initialDelaySeconds: 30\n"
    yaml = yaml + "          periodSeconds: " + str(config.health_check.interval_seconds) + "\n"
    yaml = yaml + "        readinessProbe:\n"
    yaml = yaml + "          httpGet:\n"
    yaml = yaml + "            path: " + config.health_check.path + "\n"
    yaml = yaml + "            port: " + str(config.server.port) + "\n"
    yaml = yaml + "          initialDelaySeconds: 5\n"
    yaml = yaml + "          periodSeconds: 10\n"
    
    return yaml
}

fn generateKubernetesService(config: map) -> string {
    let yaml = "# Auto-generated by SynthFlow\n"
    yaml = yaml + "apiVersion: v1\n"
    yaml = yaml + "kind: Service\n"
    yaml = yaml + "metadata:\n"
    yaml = yaml + "  name: " + config.name + "-service\n"
    yaml = yaml + "spec:\n"
    yaml = yaml + "  selector:\n"
    yaml = yaml + "    app: " + config.name + "\n"
    yaml = yaml + "  ports:\n"
    yaml = yaml + "  - protocol: TCP\n"
    yaml = yaml + "    port: 80\n"
    yaml = yaml + "    targetPort: " + str(config.server.port) + "\n"
    yaml = yaml + "  type: ClusterIP\n"
    
    return yaml
}

fn generateKubernetesHPA(config: map) -> string {
    let yaml = "# Auto-generated by SynthFlow\n"
    yaml = yaml + "apiVersion: autoscaling/v2\n"
    yaml = yaml + "kind: HorizontalPodAutoscaler\n"
    yaml = yaml + "metadata:\n"
    yaml = yaml + "  name: " + config.name + "-hpa\n"
    yaml = yaml + "spec:\n"
    yaml = yaml + "  scaleTargetRef:\n"
    yaml = yaml + "    apiVersion: apps/v1\n"
    yaml = yaml + "    kind: Deployment\n"
    yaml = yaml + "    name: " + config.name + "\n"
    yaml = yaml + "  minReplicas: " + str(config.scaling.min_replicas) + "\n"
    yaml = yaml + "  maxReplicas: " + str(config.scaling.max_replicas) + "\n"
    yaml = yaml + "  metrics:\n"
    yaml = yaml + "  - type: Resource\n"
    yaml = yaml + "    resource:\n"
    yaml = yaml + "      name: cpu\n"
    yaml = yaml + "      target:\n"
    yaml = yaml + "        type: Utilization\n"
    yaml = yaml + "        averageUtilization: " + str(config.scaling.target_cpu_utilization) + "\n"
    
    return yaml
}

fn generateKubernetesIngress(config: map, domain: string) -> string {
    let yaml = "# Auto-generated by SynthFlow\n"
    yaml = yaml + "apiVersion: networking.k8s.io/v1\n"
    yaml = yaml + "kind: Ingress\n"
    yaml = yaml + "metadata:\n"
    yaml = yaml + "  name: " + config.name + "-ingress\n"
    yaml = yaml + "  annotations:\n"
    yaml = yaml + "    kubernetes.io/ingress.class: nginx\n"
    yaml = yaml + "spec:\n"
    yaml = yaml + "  rules:\n"
    yaml = yaml + "  - host: " + domain + "\n"
    yaml = yaml + "    http:\n"
    yaml = yaml + "      paths:\n"
    yaml = yaml + "      - path: /\n"
    yaml = yaml + "        pathType: Prefix\n"
    yaml = yaml + "        backend:\n"
    yaml = yaml + "          service:\n"
    yaml = yaml + "            name: " + config.name + "-service\n"
    yaml = yaml + "            port:\n"
    yaml = yaml + "              number: 80\n"
    
    return yaml
}

// Generate all Kubernetes manifests
fn generateKubernetesManifests(config: map, domain: string) -> map {
    return {
        "deployment": generateKubernetesDeployment(config),
        "service": generateKubernetesService(config),
        "hpa": generateKubernetesHPA(config),
        "ingress": generateKubernetesIngress(config, domain)
    }
}

// ===== Cloud Provider Configurations =====

// AWS ECS Task Definition
fn generateECSTaskDefinition(config: map) -> map {
    return {
        "family": config.name,
        "networkMode": "awsvpc",
        "requiresCompatibilities": ["FARGATE"],
        "cpu": config.resources.cpu,
        "memory": config.resources.memory,
        "containerDefinitions": [{
            "name": config.name,
            "image": config.name + ":latest",
            "portMappings": [{
                "containerPort": config.server.port,
                "protocol": "tcp"
            }],
            "environment": mapToEnvArray(config.env_vars),
            "healthCheck": {
                "command": ["CMD-SHELL", "curl -f http://localhost:" + str(config.server.port) + config.health_check.path + " || exit 1"],
                "interval": config.health_check.interval_seconds,
                "timeout": config.health_check.timeout_seconds,
                "retries": 3
            },
            "logConfiguration": {
                "logDriver": "awslogs",
                "options": {
                    "awslogs-group": "/ecs/" + config.name,
                    "awslogs-region": "us-east-1",
                    "awslogs-stream-prefix": "ecs"
                }
            }
        }]
    }
}

// Google Cloud Run Configuration
fn generateCloudRunConfig(config: map) -> map {
    return {
        "apiVersion": "serving.knative.dev/v1",
        "kind": "Service",
        "metadata": {
            "name": config.name
        },
        "spec": {
            "template": {
                "spec": {
                    "containers": [{
                        "image": "gcr.io/PROJECT_ID/" + config.name + ":latest",
                        "ports": [{
                            "containerPort": config.server.port
                        }],
                        "resources": {
                            "limits": {
                                "cpu": config.resources.cpu,
                                "memory": config.resources.memory
                            }
                        },
                        "env": mapToEnvArray(config.env_vars)
                    }],
                    "containerConcurrency": 80
                },
                "metadata": {
                    "annotations": {
                        "autoscaling.knative.dev/minScale": str(config.scaling.min_replicas),
                        "autoscaling.knative.dev/maxScale": str(config.scaling.max_replicas)
                    }
                }
            }
        }
    }
}

// Azure Container Instances
fn generateAzureContainerConfig(config: map) -> map {
    return {
        "location": "eastus",
        "properties": {
            "containers": [{
                "name": config.name,
                "properties": {
                    "image": config.name + ":latest",
                    "ports": [{
                        "port": config.server.port
                    }],
                    "resources": {
                        "requests": {
                            "cpu": float(config.resources.cpu),
                            "memoryInGB": 1.0
                        }
                    },
                    "environmentVariables": mapToEnvArray(config.env_vars)
                }
            }],
            "osType": "Linux",
            "restartPolicy": "Always",
            "ipAddress": {
                "type": "Public",
                "ports": [{
                    "protocol": "TCP",
                    "port": config.server.port
                }]
            }
        }
    }
}

// ===== Deployment Scripts =====

fn generateDeployScript(config: map, platform: string) -> string {
    let script = "#!/bin/bash\n"
    script = script + "# Auto-generated by SynthFlow\n\n"
    
    if (platform == "docker") {
        script = script + "echo 'Building Docker image...'\n"
        script = script + "docker build -t " + config.name + ":latest .\n\n"
        script = script + "echo 'Running container...'\n"
        script = script + "docker run -d -p " + str(config.server.port) + ":" + str(config.server.port) + " " + config.name + ":latest\n"
    } else if (platform == "kubernetes") {
        script = script + "echo 'Building Docker image...'\n"
        script = script + "docker build -t " + config.name + ":latest .\n\n"
        script = script + "echo 'Applying Kubernetes manifests...'\n"
        script = script + "kubectl apply -f kubernetes/deployment.yaml\n"
        script = script + "kubectl apply -f kubernetes/service.yaml\n"
        script = script + "kubectl apply -f kubernetes/hpa.yaml\n"
        script = script + "kubectl apply -f kubernetes/ingress.yaml\n"
    } else if (platform == "aws") {
        script = script + "echo 'Building and pushing to ECR...'\n"
        script = script + "aws ecr get-login-password | docker login --username AWS --password-stdin $ECR_REGISTRY\n"
        script = script + "docker build -t " + config.name + " .\n"
        script = script + "docker tag " + config.name + ":latest $ECR_REGISTRY/" + config.name + ":latest\n"
        script = script + "docker push $ECR_REGISTRY/" + config.name + ":latest\n\n"
        script = script + "echo 'Updating ECS service...'\n"
        script = script + "aws ecs update-service --cluster $CLUSTER_NAME --service " + config.name + " --force-new-deployment\n"
    } else if (platform == "gcp") {
        script = script + "echo 'Building and deploying to Cloud Run...'\n"
        script = script + "gcloud builds submit --tag gcr.io/$PROJECT_ID/" + config.name + "\n"
        script = script + "gcloud run deploy " + config.name + " --image gcr.io/$PROJECT_ID/" + config.name + " --platform managed\n"
    }
    
    script = script + "\necho 'Deployment complete!'\n"
    
    return script
}

// ===== Utility Functions =====

fn mapToEnvArray(envVars: map) -> array {
    let result = []
    let envKeys = keys(envVars)
    for (let i = 0; i < len(envKeys); i = i + 1) {
        result = append(result, {
            "name": envKeys[i],
            "value": envVars[envKeys[i]]
        })
    }
    return result
}

fn keys(m: map) -> array {
    return []
}
